# 形式化方法

## 概述

### 应用

- 软件测试
- 程序验证 Program verfication（比测试更严格，他要证明对任何输入，程序都是正确的）
- 程序合成 Program synthesis：自动生成程序
- 模型检测 Model checking
- 计算机安全、测试用例生成、类型理论（如多态）、优化……

### 课程内容

1. 关于程序、语言、系统的数学。如何形式化的刻划一个系统
2. 证明论和可满足性
   1. 基于归纳证明的 归纳法（induction）
   2. SAT ， SMT
3. 建模：理论的应用

## 数学基础

### 1. 集合关系函数

**幂集**（powerset)，即 A 的子集构成的集合。 $p(A)=\{B|B\subseteq A\}$

**关系**：笛卡儿积，元组 Tuple，定义域 $Dom\  \#1\ R$，表示取 R 中元素的第一个，的集合，作为定义域

**函数**：集合上的一一对应关系。全函数 total，部分函数 partial

### 2. 基本计算复杂性结论

一个问题到底能不能用计算机解决？如果能，它的上界是多少。不同于《算法导论》中研究的，其收录的问题一定是可以用计算机解决的。

==undecidablity==：不可判定/计算问题，不会有计算机可解决的算法（不等于不可解决）。实际上是限制了**基于图灵机模型进行编程，一定解决不了的问题**。图灵机的表达能力有限

比如”停机问题“：写一个程序，接受另一个程序的代码，判断这个程序是否会中止。（简单来说，如果存在一个能够解决停机问题的算法，我们可以利用该算法构造一个新的程序，使得它在给定输入上的行为与停机问题的回答相矛盾。这样，停机问题就陷入了自相矛盾的境地，因此无法得到确定的结果。）

或者说最优化问题：能不能写一个编译器，能够优化所有的代码？不可以

==P 问题==（Polynomial）多项式复杂度，P 复杂度，是可解决问题中最简单的

==NP 问题==(Non-deterministic Polynomial)：非确定多项式实现（而不是非多项式，只是没确定。$P?=NP$）。**求解很困难 $O(2^n)$，但是验证解很简单 $O(n^k)$**

==NPC 问题==(NP-Complete)：NP 完全问题，最难的 NP 问题，解决了这个就能解决其他。比如**SAT**问题

==NP-Hard==，更难。对解的验证都需要指数时间，超出了计算机科学需要关心的问题。比如生成 1-n 共计 n 个数的全排列。求解和验证求得对不对都是$O(n!)$

## 上下文无关文法

Context-free Grammar
